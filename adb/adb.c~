#include <stdint.h>
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/cm3/systick.h>


int main(void) {
  rcc_clock_setup_in_hse_8mhz_out_72mhz();

  // Set up 1kHz systick
  systick_set_reload((STK_CALIB & STK_CALIB_TENMS) / 10);
  systick_clear();
  systick_counter_enable();
  
  
  
  

  return 0;
}

// Timer setup for dma-based output compare to generate ADB signalling.
// Every command has the same prelude, viz:
// Signal high to start with.
// pull signal low for 800 µsec (ATTN)
// drive signal high for 70 µsec (SYNC)

// We then have a train of 8 bits, each 100 µsec long.  Duty cycle
// indicates content.

// There is then a 65 µsec low "stop", and we go to input mode for
// 200 µsec.  This is the SRQ period, if we are asking for data the line
// will be pulled low by the device

// We may then send data to the device.  This involves a single "1" start bit
// 35 µsec low, 65 µsec high, 2 to 8 bytes of data, and a single "0" stop bit
// 65 µsec low, 35 µsec high.

// If the device sends data to us, we expect a single "1" start bit, 2 to 8
// bytes of data, and a single "0" stop bit as above.

// The "fixed" parts can all be generated using one pulse mode
// The bytes of data, on the other hand, we will generate using DMA and
// output compare mode.  Or maybe pwm mode.  Not sure about that.

// We will be using timer 2 channel 1 for all this, remapped onto PA15, which
// is 5v tolerant.  

TIM_HandleTypeDef htim2;

void init_adb() {
  // Enable the clocks
  rcc_periph_clock_enable(RCC_GPIOB);
  rcc_periph_clock_enable(RCC_TIM3);

  timer_set_prescaler(TIM3, 71);
  timer_direction_down(TIM3);
  timer_set_period(TIM3, 100);
  timer_set_clock_division(TIM3, 1);
  timer_enable_preload(TIM3);
}

void adb_prepare_output() {
  // Initialise the pin
  gpio_set_mode(GPIO_BANK_TIM3_CH4, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO_TIM3_CH4);
}

void adb_prepare_input() {
  // Initialise the pin
  gpio_set_mode(GPIO_BANK_TIM3_CH4, GPIO_MODE_INPUT, GPIO_CNF_INPUT_PULL_UPDOWN, GPIO_TIM3_CH4);
}


struct {
  uint32_t count;
  uint32_t bits[64];
  uint32_t stop_bit;
} adb_send_data;


// This will send one start bit, /count/ sets of 8 bits, and a stop bit. 
void adb_send_bytes(dma_callback_t cb) {  
  // Set up the timer for PWM, 100 µsec period, initial 1 start pulse
  timer_set_period(TIM3, 100);
  timer_enable_oc_preload(TIM3, TIM_OC4);

  // Set up our callback and kick off the DMA
  dma_callback = cb;
  HAL_TIM_PWM_Start_DMA(&htim2, TIM_CHANNEL_1, adb_send_data.bits, adb_send_data.count);
}

void attn_sync() {
}

